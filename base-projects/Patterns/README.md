# آزمایش شماره V (بازآرایی) - اعمال الگوی Facade

<div dir="rtl">

## هدف
ساده‌سازی فرآیند راه‌اندازی و تعامل با کامپونت‌های پیچیده در سیستم‌های تجزیه‌گر (Parser) با استفاده از الگوی Facade.

## مشکل
- تعامل مستقیم با چندین کامپونت مانند `CodeGenerator`، `ParseTable` و `Rule` نیازمند راه‌اندازی و مدیریت جداگانه است.
- این رویکرد باعث پیچیدگی کد مشتری، وابستگی زیاد به جزئیات داخلی، و کاهش خوانایی و قابلیت نگهداری می‌شود.

## راه‌حل
ایجاد کلاس `ParserFacade` برای:
- پنهان کردن پیچیدگی‌های راه‌اندازی کامپونت‌ها.
- ارائه یک رابط ساده و یکپارچه به مشتری.

### نمونه کد
```java
public class ParseFacade {
    private Parser parser;

    public ParseFacade() {
        parser = new Parser();
    }

    public void parseFile(String filePath) {
        try {
            Scanner sc = new Scanner(new File(filePath));
            parser.startParse(sc);
        } catch (FileNotFoundException e) {
            ErrorHandler.printError(e.getMessage());
        }
    }
}

```
## مزایای کلیدی الگوی Facade

- **ساده‌سازی کد مشتری**:  
  مشتری تنها با `ParserFacade` تعامل دارد و نیازی به مدیریت جزئیات داخلی کامپونت‌ها ندارد.

- **کاهش وابستگی‌ها**:  
  تغییرات در کامپونت‌های داخلی (مانند `CodeGenerator` یا `ParseTable`) تأثیر کمتری بر کد مشتری می‌گذارد.

- **افزایش خوانایی**:  
  رابط تمیز و سطح بالا، کد را برای توسعه‌دهندگان قابل‌درک‌تر و قابل‌نگهداری می‌کند.

- **نگهداری آسان‌تر**:  
  تغییرات در منطق راه‌اندازی تنها در کلاس `ParserFacade` اعمال می‌شوند و نیازی به اصلاح کد مشتری نیست.

## نتیجه‌گیری نهایی

با اعمال الگوی **Facade**:
- ✅ پیچیدگی‌های سیستم به‌طور مؤثر مدیریت شد.  
- ✅ کد مشتری ساده‌تر و با قابلیت نگهداری بالاتر طراحی شد.  
- ✅ قابلیت توسعه و انعطاف‌پذیری سیستم بهبود یافت.  

</div>
